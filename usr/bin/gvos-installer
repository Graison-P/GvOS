#!/bin/bash

################################################################################
# GvOS Fullscreen Installer
# 
# A fullscreen, kernel-based installer for GvOS designed to mimic the 
# functionality and aesthetics of the Ubuntu Server installer.
#
# This installer runs entirely in a kernel TTY environment with no reliance
# on graphical utilities - it's fully text-based.
#
# Features:
# - Network selection (Wi-Fi with nmcli)
# - Partition and installation setup
# - Customization options with custom command section
# - Expandable modules for package installation
#
# Author: GvOS Development Team
# License: See LICENSE file
################################################################################

# Exit on error, undefined variables, and pipe failures
set -euo pipefail

################################################################################
# CONFIGURATION SECTION
# Edit these variables to customize the installer behavior
################################################################################

# Installer version
readonly INSTALLER_VERSION="1.0.0"

# Colors for the installer UI (using ANSI escape codes)
readonly COLOR_RESET='\033[0m'
readonly COLOR_BOLD='\033[1m'
readonly COLOR_RED='\033[0;31m'
readonly COLOR_GREEN='\033[0;32m'
readonly COLOR_YELLOW='\033[0;33m'
readonly COLOR_BLUE='\033[0;34m'
readonly COLOR_CYAN='\033[0;36m'
readonly COLOR_WHITE='\033[0;37m'
readonly COLOR_BG_BLUE='\033[44m'
readonly COLOR_BG_WHITE='\033[47m'

# Default installation settings
DEFAULT_HOSTNAME="gvos"
DEFAULT_USERNAME="gvos"
DEFAULT_TIMEZONE="UTC"

# Debian release settings
DEBIAN_RELEASE="stable"  # stable, testing, unstable, or codename (e.g., bookworm)
DEBIAN_MIRROR="http://deb.debian.org/debian"
DEBIAN_SECURITY_MIRROR="http://security.debian.org/debian-security"

# Installation paths
INSTALL_ROOT="/mnt/gvos"
LOG_FILE="/var/log/gvos-installer.log"

# Package groups for expandable modules
declare -A PACKAGE_GROUPS=(
    ["base"]="systemd udev bash coreutils util-linux"
    ["network"]="network-manager iproute2 iputils-ping wireless-tools wpasupplicant"
    ["development"]="build-essential git vim gcc make"
    ["desktop"]="xorg lightdm lxde firefox-esr"
    ["server"]="openssh-server apache2 nginx mysql-server"
    ["multimedia"]="vlc gimp inkscape audacity"
)

# Post-installation commands
# These commands are automatically executed after Debian is installed and packages are installed
# Add your custom commands here to install additional packages or configure the system
# Each command will be executed in the chroot environment
declare -a POST_INSTALL_COMMANDS=(
    # System utilities and tools
    "apt-get install -y curl wget ca-certificates gnupg"
    "apt-get install -y htop neofetch net-tools"
    
    # Text editors
    "apt-get install -y nano"
    
    # Enable and configure services
    # "systemctl enable ssh"  # Uncomment to enable SSH by default
    
    # Add any additional commands here
    # Examples:
    # "apt-get install -y your-package"
    # "systemctl enable your-service"
    # "echo 'your-config' > /etc/your-config-file"
)

################################################################################
# GLOBAL VARIABLES
# These are set during the installation process
################################################################################

SELECTED_DISK=""
SELECTED_PARTITION_ROOT=""
SELECTED_PARTITION_BOOT=""
SELECTED_NETWORK=""
NETWORK_PASSWORD=""
HOSTNAME=""
USERNAME=""
USER_PASSWORD=""
ROOT_PASSWORD=""
TIMEZONE=""
INSTALL_PACKAGES=()
DEBIAN_CODENAME=""
ACTUAL_INSTALL_MODE=false  # Set to true to perform actual installation

################################################################################
# UTILITY FUNCTIONS
# Helper functions for the installer UI and operations
################################################################################

# Log messages to both console and log file
log_message() {
    local message="$1"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[${timestamp}] ${message}" | tee -a "${LOG_FILE}"
}

# Display error message and exit
error_exit() {
    local message="$1"
    echo -e "${COLOR_RED}${COLOR_BOLD}ERROR:${COLOR_RESET} ${message}" >&2
    log_message "ERROR: ${message}"
    cleanup_and_exit 1
}

# Cleanup and exit
cleanup_and_exit() {
    local exit_code="${1:-0}"
    
    # Unmount filesystems if they were mounted
    if [ -n "${INSTALL_ROOT}" ] && [ -d "${INSTALL_ROOT}" ]; then
        if mountpoint -q "${INSTALL_ROOT}/dev/pts" 2>/dev/null; then
            echo "Unmounting filesystems..."
            umount "${INSTALL_ROOT}/dev/pts" 2>/dev/null || true
            umount "${INSTALL_ROOT}/dev" 2>/dev/null || true
            umount "${INSTALL_ROOT}/proc" 2>/dev/null || true
            umount "${INSTALL_ROOT}/sys" 2>/dev/null || true
            if [ -d "${INSTALL_ROOT}/boot/efi" ]; then
                umount "${INSTALL_ROOT}/boot/efi" 2>/dev/null || true
            fi
            umount "${INSTALL_ROOT}" 2>/dev/null || true
        fi
    fi
    
    # Restore normal terminal
    tput cnorm 2>/dev/null || true
    reset
    exit "${exit_code}"
}

# Clear screen and show header
show_header() {
    clear
    echo -e "${COLOR_BG_BLUE}${COLOR_WHITE}${COLOR_BOLD}"
    echo "╔════════════════════════════════════════════════════════════════════════════╗"
    echo "║                          GvOS Installer v${INSTALLER_VERSION}                          ║"
    echo "╚════════════════════════════════════════════════════════════════════════════╝"
    echo -e "${COLOR_RESET}"
    echo ""
}

# Display a message box
message_box() {
    local title="$1"
    local message="$2"
    
    show_header
    echo -e "${COLOR_CYAN}${COLOR_BOLD}=== ${title} ===${COLOR_RESET}"
    echo ""
    echo -e "${message}"
    echo ""
}

# Display a prompt and get user input
prompt_input() {
    local prompt="$1"
    local default="${2:-}"
    local result
    
    if [ -n "${default}" ]; then
        echo -ne "${COLOR_GREEN}${prompt}${COLOR_RESET} [${default}]: "
    else
        echo -ne "${COLOR_GREEN}${prompt}${COLOR_RESET}: "
    fi
    
    read -r result
    
    if [ -z "${result}" ] && [ -n "${default}" ]; then
        echo "${default}"
    else
        echo "${result}"
    fi
}

# Display a yes/no prompt
prompt_yes_no() {
    local prompt="$1"
    local default="${2:-n}"
    local result
    
    while true; do
        if [ "${default}" = "y" ]; then
            echo -ne "${COLOR_GREEN}${prompt}${COLOR_RESET} [Y/n]: "
        else
            echo -ne "${COLOR_GREEN}${prompt}${COLOR_RESET} [y/N]: "
        fi
        
        read -r result
        result="${result:-${default}}"
        
        case "${result,,}" in
            y|yes) return 0 ;;
            n|no) return 1 ;;
            *) echo "Please answer yes or no." ;;
        esac
    done
}

# Display a menu and get user selection
show_menu() {
    local title="$1"
    shift
    local options=("$@")
    local choice
    
    show_header
    echo -e "${COLOR_CYAN}${COLOR_BOLD}=== ${title} ===${COLOR_RESET}"
    echo ""
    
    for i in "${!options[@]}"; do
        echo -e "  ${COLOR_BOLD}$((i + 1)))${COLOR_RESET} ${options[$i]}"
    done
    
    echo ""
    while true; do
        echo -ne "${COLOR_GREEN}Select an option (1-${#options[@]}):${COLOR_RESET} "
        read -r choice
        
        if [[ "${choice}" =~ ^[0-9]+$ ]] && [ "${choice}" -ge 1 ] && [ "${choice}" -le "${#options[@]}" ]; then
            return $((choice - 1))
        fi
        
        echo -e "${COLOR_RED}Invalid selection. Please try again.${COLOR_RESET}"
    done
}

# Display progress bar
show_progress() {
    local current="$1"
    local total="$2"
    local message="${3:-Processing}"
    local percent=$((current * 100 / total))
    local filled=$((percent / 2))
    local empty=$((50 - filled))
    
    printf "\r${COLOR_CYAN}${message}:${COLOR_RESET} ["
    printf "%${filled}s" | tr ' ' '='
    printf "%${empty}s" | tr ' ' ' '
    printf "] %3d%%" "${percent}"
}

################################################################################
# INSTALLATION STEP FUNCTIONS
# Each function handles a specific step of the installation process
################################################################################

# Step 1: Welcome screen
step_welcome() {
    message_box "Welcome to GvOS Installer" \
"Welcome to the GvOS installation program!

This installer will guide you through the process of installing GvOS
on your system. The installation process includes:

  • Network configuration (Wi-Fi/Ethernet)
  • Disk partitioning and formatting
  • Base system installation
  • User account creation
  • Package selection and installation
  • System customization

${COLOR_YELLOW}NOTE:${COLOR_RESET} This installer requires root privileges and will make changes
to your disk. Make sure you have backed up any important data.

Press ENTER to continue..."
    
    read -r
}

# Step 2: Check prerequisites
step_check_prerequisites() {
    message_box "Checking Prerequisites" "Verifying system requirements..."
    
    log_message "Checking prerequisites..."
    
    # Check if running as root
    if [ "$(id -u)" -ne 0 ]; then
        error_exit "This installer must be run as root. Please use 'sudo'."
    fi
    
    # Check for required commands
    local required_cmds=("debootstrap" "fdisk" "mkfs.ext4" "mount" "chroot")
    local optional_cmds=("nmcli" "parted" "lsblk")
    local missing_cmds=()
    local missing_optional=()
    
    for cmd in "${required_cmds[@]}"; do
        if ! command -v "${cmd}" &> /dev/null; then
            missing_cmds+=("${cmd}")
        fi
    done
    
    for cmd in "${optional_cmds[@]}"; do
        if ! command -v "${cmd}" &> /dev/null; then
            missing_optional+=("${cmd}")
        fi
    done
    
    if [ ${#missing_cmds[@]} -gt 0 ]; then
        echo -e "${COLOR_RED}Error: The following required commands are missing:${COLOR_RESET}"
        printf '  - %s\n' "${missing_cmds[@]}"
        echo ""
        echo "Please install them before running the installer:"
        echo "  apt-get install debootstrap fdisk e2fsprogs"
        echo ""
        if ! prompt_yes_no "Continue anyway (simulation mode)?" "n"; then
            cleanup_and_exit 1
        fi
        ACTUAL_INSTALL_MODE=false
    else
        ACTUAL_INSTALL_MODE=true
    fi
    
    if [ ${#missing_optional[@]} -gt 0 ]; then
        echo -e "${COLOR_YELLOW}Warning: The following optional commands are not available:${COLOR_RESET}"
        printf '  - %s\n' "${missing_optional[@]}"
        echo ""
    fi
    
    echo -e "${COLOR_GREEN}✓ Prerequisites check completed${COLOR_RESET}"
    
    # Detect Debian release if in actual install mode
    if [ "${ACTUAL_INSTALL_MODE}" = true ]; then
        echo ""
        echo "Detecting latest Debian release..."
        detect_debian_release
        echo -e "${COLOR_GREEN}✓ Will install Debian ${DEBIAN_CODENAME}${COLOR_RESET}"
    fi
    
    sleep 1
}

# Helper function to detect latest Debian release
detect_debian_release() {
    # Try to detect the latest stable Debian release
    # First, try to get it from the Debian API
    if command -v curl &> /dev/null; then
        local release_info
        release_info=$(curl -s "https://www.debian.org/releases/stable/" 2>/dev/null | grep -oP 'Debian \K[0-9.]+' | head -1)
        if [ -n "${release_info}" ]; then
            log_message "Detected Debian version: ${release_info}"
        fi
    fi
    
    # Get codename from debootstrap scripts
    if [ -d "/usr/share/debootstrap/scripts" ]; then
        # Find the symlink for 'stable'
        if [ -L "/usr/share/debootstrap/scripts/stable" ]; then
            DEBIAN_CODENAME=$(readlink "/usr/share/debootstrap/scripts/stable" | xargs basename)
            log_message "Detected Debian codename from debootstrap: ${DEBIAN_CODENAME}"
        else
            # Default to bookworm (Debian 12, stable as of 2023-2025)
            DEBIAN_CODENAME="bookworm"
            log_message "Using default Debian codename: ${DEBIAN_CODENAME}"
        fi
    else
        # Fallback to a known stable release
        DEBIAN_CODENAME="bookworm"
        log_message "Using fallback Debian codename: ${DEBIAN_CODENAME}"
    fi
    
    # If DEBIAN_RELEASE is a specific codename, use it
    if [[ "${DEBIAN_RELEASE}" =~ ^(bookworm|bullseye|trixie|sid)$ ]]; then
        DEBIAN_CODENAME="${DEBIAN_RELEASE}"
    fi
}

# Step 3: Network configuration
step_network_configuration() {
    show_header
    echo -e "${COLOR_CYAN}${COLOR_BOLD}=== Network Configuration ===${COLOR_RESET}"
    echo ""
    
    log_message "Configuring network..."
    
    # Check if NetworkManager is available
    if ! command -v nmcli &> /dev/null; then
        echo -e "${COLOR_YELLOW}NetworkManager not found. Skipping network configuration.${COLOR_RESET}"
        sleep 2
        return
    fi
    
    echo "Scanning for available networks..."
    sleep 1
    
    # Get list of Wi-Fi networks
    local networks=()
    local ssid
    while IFS= read -r ssid; do
        if [ -n "${ssid}" ]; then
            networks+=("${ssid}")
        fi
    done < <(nmcli -t -f SSID device wifi list 2>/dev/null | sort -u | grep -v '^$' || true)
    
    if [ ${#networks[@]} -eq 0 ]; then
        echo -e "${COLOR_YELLOW}No Wi-Fi networks found.${COLOR_RESET}"
        echo ""
        if prompt_yes_no "Skip network configuration?" "y"; then
            return
        fi
    else
        echo ""
        echo "Available Wi-Fi networks:"
        for i in "${!networks[@]}"; do
            echo -e "  ${COLOR_BOLD}$((i + 1)))${COLOR_RESET} ${networks[$i]}"
        done
        echo -e "  ${COLOR_BOLD}$((${#networks[@]} + 1)))${COLOR_RESET} Skip network configuration"
        echo ""
        
        local choice
        while true; do
            echo -ne "${COLOR_GREEN}Select a network (1-$((${#networks[@]} + 1))):${COLOR_RESET} "
            read -r choice
            
            if [[ "${choice}" =~ ^[0-9]+$ ]] && [ "${choice}" -ge 1 ] && [ "${choice}" -le $((${#networks[@]} + 1)) ]; then
                break
            fi
            echo -e "${COLOR_RED}Invalid selection.${COLOR_RESET}"
        done
        
        if [ "${choice}" -le "${#networks[@]}" ]; then
            SELECTED_NETWORK="${networks[$((choice - 1))]}"
            echo ""
            echo -ne "${COLOR_GREEN}Enter password for '${SELECTED_NETWORK}':${COLOR_RESET} "
            read -rs NETWORK_PASSWORD
            echo ""
            
            echo "Connecting to '${SELECTED_NETWORK}'..."
            # Use stdin to avoid exposing password in process list
            if printf "%s\n" "${NETWORK_PASSWORD}" | nmcli device wifi connect "${SELECTED_NETWORK}" password-stdin 2>/dev/null; then
                echo -e "${COLOR_GREEN}✓ Connected successfully${COLOR_RESET}"
                log_message "Connected to network: ${SELECTED_NETWORK}"
            else
                echo -e "${COLOR_RED}✗ Failed to connect${COLOR_RESET}"
                log_message "Failed to connect to network: ${SELECTED_NETWORK}"
                if ! prompt_yes_no "Continue without network?" "n"; then
                    cleanup_and_exit 0
                fi
            fi
            # Clear password from memory
            NETWORK_PASSWORD=""
        fi
    fi
    
    echo ""
    echo "Press ENTER to continue..."
    read -r
}

# Step 4: Disk partitioning
step_disk_partitioning() {
    show_header
    echo -e "${COLOR_CYAN}${COLOR_BOLD}=== Disk Partitioning ===${COLOR_RESET}"
    echo ""
    
    log_message "Starting disk partitioning..."
    
    # List available disks
    echo "Available disks:"
    while IFS= read -r name size _; do
        echo -e "  ${COLOR_BOLD}/dev/${name}${COLOR_RESET} - ${size}"
    done < <(lsblk -d -n -o NAME,SIZE,TYPE | grep disk)
    echo ""
    
    # Get disk selection
    local disk
    while true; do
        disk=$(prompt_input "Enter the disk to install GvOS on (e.g., sda, vda)" "")
        
        if [ -b "/dev/${disk}" ]; then
            SELECTED_DISK="/dev/${disk}"
            break
        fi
        echo -e "${COLOR_RED}Disk /dev/${disk} not found. Please try again.${COLOR_RESET}"
    done
    
    echo ""
    echo -e "${COLOR_RED}${COLOR_BOLD}WARNING:${COLOR_RESET} All data on ${SELECTED_DISK} will be DESTROYED!"
    echo ""
    
    if ! prompt_yes_no "Are you sure you want to continue?" "n"; then
        cleanup_and_exit 0
    fi
    
    # Partition the disk
    echo ""
    echo "Partitioning ${SELECTED_DISK}..."
    log_message "Partitioning disk: ${SELECTED_DISK}"
    
    if [ "${ACTUAL_INSTALL_MODE}" = true ]; then
        # Actual disk partitioning
        echo "Creating partition table..."
        
        # Check if system uses UEFI or BIOS
        local firmware_type="bios"
        if [ -d "/sys/firmware/efi" ]; then
            firmware_type="uefi"
            echo "Detected UEFI firmware"
        else
            echo "Detected BIOS firmware"
        fi
        
        # Unmount any existing partitions on the disk
        for partition in "${SELECTED_DISK}"*; do
            if [ -b "${partition}" ]; then
                umount "${partition}" 2>/dev/null || true
            fi
        done
        
        # Create new partition table
        if [ "${firmware_type}" = "uefi" ]; then
            # UEFI: GPT partition table with EFI partition
            echo "Creating GPT partition table for UEFI..."
            parted -s "${SELECTED_DISK}" mklabel gpt
            parted -s "${SELECTED_DISK}" mkpart primary fat32 1MiB 513MiB
            parted -s "${SELECTED_DISK}" set 1 esp on
            parted -s "${SELECTED_DISK}" mkpart primary ext4 513MiB 100%
            
            SELECTED_PARTITION_BOOT="${SELECTED_DISK}1"
            SELECTED_PARTITION_ROOT="${SELECTED_DISK}2"
            
            # Format partitions
            echo "Formatting EFI partition..."
            mkfs.fat -F32 "${SELECTED_PARTITION_BOOT}"
            
        else
            # BIOS: MBR partition table
            echo "Creating MBR partition table for BIOS..."
            parted -s "${SELECTED_DISK}" mklabel msdos
            parted -s "${SELECTED_DISK}" mkpart primary ext4 1MiB 100%
            parted -s "${SELECTED_DISK}" set 1 boot on
            
            SELECTED_PARTITION_ROOT="${SELECTED_DISK}1"
        fi
        
        # Format root partition
        echo "Formatting root partition..."
        mkfs.ext4 -F "${SELECTED_PARTITION_ROOT}"
        
        # Mount partitions
        echo "Mounting partitions..."
        mkdir -p "${INSTALL_ROOT}"
        mount "${SELECTED_PARTITION_ROOT}" "${INSTALL_ROOT}"
        
        if [ "${firmware_type}" = "uefi" ]; then
            mkdir -p "${INSTALL_ROOT}/boot/efi"
            mount "${SELECTED_PARTITION_BOOT}" "${INSTALL_ROOT}/boot/efi"
        fi
        
        echo -e "${COLOR_GREEN}✓ Disk partitioning completed${COLOR_RESET}"
        log_message "Partitioning completed: boot=${SELECTED_PARTITION_BOOT:-none}, root=${SELECTED_PARTITION_ROOT}"
    else
        # Simulation mode
        echo -e "${COLOR_YELLOW}[SIMULATION MODE] Partitioning would happen here${COLOR_RESET}"
        echo "  - Creating EFI partition (512MB)"
        echo "  - Creating root partition (remaining space)"
        sleep 2
        echo -e "${COLOR_GREEN}✓ Disk partitioning completed (simulated)${COLOR_RESET}"
    fi
    
    echo ""
    echo "Press ENTER to continue..."
    read -r
}

# Step 5: Base system installation
step_base_installation() {
    show_header
    echo -e "${COLOR_CYAN}${COLOR_BOLD}=== Base System Installation ===${COLOR_RESET}"
    echo ""
    
    log_message "Installing base system..."
    
    # Create installation root if not already created
    mkdir -p "${INSTALL_ROOT}"
    
    if [ "${ACTUAL_INSTALL_MODE}" = true ]; then
        # Actual Debian installation using debootstrap
        echo ""
        echo "Installing Debian ${DEBIAN_CODENAME} base system..."
        echo "This may take several minutes depending on your network speed..."
        echo ""
        
        log_message "Running debootstrap for ${DEBIAN_CODENAME}"
        
        # Run debootstrap to install minimal Debian system
        if debootstrap --arch=amd64 "${DEBIAN_CODENAME}" "${INSTALL_ROOT}" "${DEBIAN_MIRROR}"; then
            echo ""
            echo -e "${COLOR_GREEN}✓ Base system installation completed${COLOR_RESET}"
            log_message "Debootstrap completed successfully"
            
            # Configure APT sources
            echo ""
            echo "Configuring package repositories..."
            
            # Determine if we need non-free-firmware (Debian 12+)
            local nonfree_firmware=""
            if [[ "${DEBIAN_CODENAME}" == "bookworm" || "${DEBIAN_CODENAME}" == "trixie" || "${DEBIAN_CODENAME}" == "sid" ]]; then
                nonfree_firmware=" non-free-firmware"
            fi
            
            cat > "${INSTALL_ROOT}/etc/apt/sources.list" <<EOF
# Debian ${DEBIAN_CODENAME} repositories
deb ${DEBIAN_MIRROR} ${DEBIAN_CODENAME} main contrib non-free${nonfree_firmware}
deb-src ${DEBIAN_MIRROR} ${DEBIAN_CODENAME} main contrib non-free${nonfree_firmware}

# Security updates
deb ${DEBIAN_SECURITY_MIRROR} ${DEBIAN_CODENAME}-security main contrib non-free${nonfree_firmware}
deb-src ${DEBIAN_SECURITY_MIRROR} ${DEBIAN_CODENAME}-security main contrib non-free${nonfree_firmware}

# Updates
deb ${DEBIAN_MIRROR} ${DEBIAN_CODENAME}-updates main contrib non-free${nonfree_firmware}
deb-src ${DEBIAN_MIRROR} ${DEBIAN_CODENAME}-updates main contrib non-free${nonfree_firmware}
EOF
            log_message "APT sources configured"
            
            # Mount necessary filesystems for chroot
            echo "Mounting filesystems for chroot environment..."
            mount --bind /dev "${INSTALL_ROOT}/dev"
            mount --bind /dev/pts "${INSTALL_ROOT}/dev/pts"
            mount --bind /proc "${INSTALL_ROOT}/proc"
            mount --bind /sys "${INSTALL_ROOT}/sys"
            
        else
            echo -e "${COLOR_RED}✗ Base system installation failed${COLOR_RESET}"
            log_message "ERROR: Debootstrap failed"
            if ! prompt_yes_no "Continue anyway?" "n"; then
                cleanup_and_exit 1
            fi
        fi
        
    else
        # Simulation mode
        echo ""
        echo "Installing base packages..."
        echo -e "${COLOR_YELLOW}[SIMULATION MODE] Base installation would happen here${COLOR_RESET}"
        
        local base_packages=("${PACKAGE_GROUPS[base]}" "${PACKAGE_GROUPS[network]}")
        local total=${#base_packages[@]}
        
        for i in "${!base_packages[@]}"; do
            show_progress "$((i + 1))" "${total}" "Installing base packages"
            sleep 0.1
        done
        
        echo ""
        echo ""
        echo -e "${COLOR_GREEN}✓ Base system installation completed (simulated)${COLOR_RESET}"
    fi
    
    echo ""
    echo "Press ENTER to continue..."
    read -r
}

# Step 6: User configuration
step_user_configuration() {
    show_header
    echo -e "${COLOR_CYAN}${COLOR_BOLD}=== User Configuration ===${COLOR_RESET}"
    echo ""
    
    log_message "Configuring user accounts..."
    
    # Get hostname
    HOSTNAME=$(prompt_input "Enter hostname for this system" "${DEFAULT_HOSTNAME}")
    
    # Get username
    USERNAME=$(prompt_input "Enter username for the primary user" "${DEFAULT_USERNAME}")
    
    # Get user password
    while true; do
        echo -ne "${COLOR_GREEN}Enter password for ${USERNAME}:${COLOR_RESET} "
        read -rs USER_PASSWORD
        echo ""
        echo -ne "${COLOR_GREEN}Confirm password:${COLOR_RESET} "
        read -rs password_confirm
        echo ""
        
        if [ "${USER_PASSWORD}" = "${password_confirm}" ]; then
            break
        fi
        echo -e "${COLOR_RED}Passwords do not match. Please try again.${COLOR_RESET}"
    done
    
    # Get root password
    echo ""
    if prompt_yes_no "Set a separate root password?" "n"; then
        while true; do
            echo -ne "${COLOR_GREEN}Enter root password:${COLOR_RESET} "
            read -rs ROOT_PASSWORD
            echo ""
            echo -ne "${COLOR_GREEN}Confirm password:${COLOR_RESET} "
            read -rs password_confirm
            echo ""
            
            if [ "${ROOT_PASSWORD}" = "${password_confirm}" ]; then
                break
            fi
            echo -e "${COLOR_RED}Passwords do not match. Please try again.${COLOR_RESET}"
        done
    else
        ROOT_PASSWORD="${USER_PASSWORD}"
    fi
    
    # Get timezone
    echo ""
    TIMEZONE=$(prompt_input "Enter timezone" "${DEFAULT_TIMEZONE}")
    
    echo ""
    echo -e "${COLOR_GREEN}✓ User configuration completed${COLOR_RESET}"
    echo ""
    echo "Press ENTER to continue..."
    read -r
}

# Step 7: Package selection
step_package_selection() {
    show_header
    echo -e "${COLOR_CYAN}${COLOR_BOLD}=== Package Selection ===${COLOR_RESET}"
    echo ""
    
    log_message "Selecting packages..."
    
    echo "Select package groups to install:"
    echo ""
    echo -e "  ${COLOR_BOLD}1)${COLOR_RESET} Base System (required)"
    echo -e "  ${COLOR_BOLD}2)${COLOR_RESET} Development Tools"
    echo -e "  ${COLOR_BOLD}3)${COLOR_RESET} Desktop Environment (LXDE)"
    echo -e "  ${COLOR_BOLD}4)${COLOR_RESET} Server Packages"
    echo -e "  ${COLOR_BOLD}5)${COLOR_RESET} Multimedia Applications"
    echo -e "  ${COLOR_BOLD}6)${COLOR_RESET} Custom Selection"
    echo ""
    
    INSTALL_PACKAGES=("base" "network")
    
    if prompt_yes_no "Install development tools?" "n"; then
        INSTALL_PACKAGES+=("development")
    fi
    
    if prompt_yes_no "Install desktop environment?" "n"; then
        INSTALL_PACKAGES+=("desktop")
    fi
    
    if prompt_yes_no "Install server packages?" "n"; then
        INSTALL_PACKAGES+=("server")
    fi
    
    if prompt_yes_no "Install multimedia applications?" "n"; then
        INSTALL_PACKAGES+=("multimedia")
    fi
    
    echo ""
    echo -e "${COLOR_GREEN}✓ Package selection completed${COLOR_RESET}"
    echo ""
    echo "Press ENTER to continue..."
    read -r
}

# Step 8: Custom commands section
step_custom_commands() {
    show_header
    echo -e "${COLOR_CYAN}${COLOR_BOLD}=== Custom Commands ===${COLOR_RESET}"
    echo ""
    
    log_message "Custom commands section..."
    
    echo "This section allows you to run custom sudo commands to further"
    echo "customize your installation."
    echo ""
    echo -e "${COLOR_YELLOW}Examples:${COLOR_RESET}"
    echo "  - apt-get install <package>"
    echo "  - systemctl enable <service>"
    echo "  - Custom configuration commands"
    echo ""
    echo -e "${COLOR_YELLOW}Note:${COLOR_RESET} Commands will be executed in the installation root context."
    echo ""
    
    if ! prompt_yes_no "Do you want to run custom commands?" "n"; then
        return
    fi
    
    echo ""
    echo "Enter your commands (one per line). Type 'done' when finished."
    echo ""
    
    local command
    local commands=()
    
    while true; do
        echo -ne "${COLOR_GREEN}Command>${COLOR_RESET} "
        read -r command
        
        if [ "${command}" = "done" ]; then
            break
        fi
        
        if [ -n "${command}" ]; then
            commands+=("${command}")
            echo -e "${COLOR_YELLOW}[QUEUED]${COLOR_RESET} ${command}"
        fi
    done
    
    if [ ${#commands[@]} -gt 0 ]; then
        echo ""
        echo "Executing custom commands..."
        log_message "Executing ${#commands[@]} custom commands"
        
        for cmd in "${commands[@]}"; do
            echo -e "${COLOR_CYAN}→${COLOR_RESET} ${cmd}"
            log_message "Custom command: ${cmd}"
            
            if [ "${ACTUAL_INSTALL_MODE}" = true ]; then
                # Execute in chroot environment
                if chroot "${INSTALL_ROOT}" /bin/bash -c "${cmd}"; then
                    echo -e "${COLOR_GREEN}  ✓ Success${COLOR_RESET}"
                else
                    echo -e "${COLOR_RED}  ✗ Failed (exit code: $?)${COLOR_RESET}"
                fi
            else
                echo -e "${COLOR_YELLOW}[SIMULATION MODE] Would execute: ${cmd}${COLOR_RESET}"
                sleep 0.5
            fi
        done
        
        echo ""
        echo -e "${COLOR_GREEN}✓ Custom commands executed${COLOR_RESET}"
    fi
    
    echo ""
    echo "Press ENTER to continue..."
    read -r
}

# Step 9: Installation summary
step_installation_summary() {
    show_header
    echo -e "${COLOR_CYAN}${COLOR_BOLD}=== Installation Summary ===${COLOR_RESET}"
    echo ""
    
    echo -e "${COLOR_BOLD}Installation Settings:${COLOR_RESET}"
    if [ "${ACTUAL_INSTALL_MODE}" = true ]; then
        echo "  Mode:            ${COLOR_GREEN}Actual Installation${COLOR_RESET}"
        echo "  Debian Release:  ${DEBIAN_CODENAME}"
    else
        echo "  Mode:            ${COLOR_YELLOW}Simulation${COLOR_RESET}"
    fi
    echo "  Hostname:        ${HOSTNAME}"
    echo "  Username:        ${USERNAME}"
    echo "  Timezone:        ${TIMEZONE}"
    echo "  Disk:            ${SELECTED_DISK}"
    if [ -n "${SELECTED_NETWORK}" ]; then
        echo "  Network:         ${SELECTED_NETWORK}"
    fi
    echo ""
    echo -e "${COLOR_BOLD}Package Groups:${COLOR_RESET}"
    for group in "${INSTALL_PACKAGES[@]}"; do
        echo "  - ${group}"
    done
    echo ""
    
    if ! prompt_yes_no "Proceed with installation?" "y"; then
        echo ""
        if prompt_yes_no "Exit installer?" "n"; then
            cleanup_and_exit 0
        else
            return 1
        fi
    fi
    
    return 0
}

# Step 10: Perform installation
step_perform_installation() {
    show_header
    echo -e "${COLOR_CYAN}${COLOR_BOLD}=== Installing GvOS ===${COLOR_RESET}"
    echo ""
    
    log_message "Starting installation configuration..."
    
    if [ "${ACTUAL_INSTALL_MODE}" = true ]; then
        # Configure the installed system
        
        # Set hostname
        echo "Setting hostname..."
        echo "${HOSTNAME}" > "${INSTALL_ROOT}/etc/hostname"
        cat > "${INSTALL_ROOT}/etc/hosts" <<EOF
127.0.0.1   localhost
127.0.1.1   ${HOSTNAME}

# The following lines are desirable for IPv6 capable hosts
::1     localhost ip6-localhost ip6-loopback
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
EOF
        log_message "Hostname set to: ${HOSTNAME}"
        
        # Set timezone
        echo "Configuring timezone..."
        chroot "${INSTALL_ROOT}" ln -sf "/usr/share/zoneinfo/${TIMEZONE}" /etc/localtime
        log_message "Timezone set to: ${TIMEZONE}"
        
        # Configure locale
        echo "Configuring locale..."
        echo "en_US.UTF-8 UTF-8" >> "${INSTALL_ROOT}/etc/locale.gen"
        chroot "${INSTALL_ROOT}" locale-gen
        echo "LANG=en_US.UTF-8" > "${INSTALL_ROOT}/etc/default/locale"
        
        # Create user account
        echo "Creating user account..."
        
        # Ensure sudo package is installed
        chroot "${INSTALL_ROOT}" apt-get install -y sudo
        
        chroot "${INSTALL_ROOT}" useradd -m -s /bin/bash "${USERNAME}"
        echo "${USERNAME}:${USER_PASSWORD}" | chroot "${INSTALL_ROOT}" chpasswd
        chroot "${INSTALL_ROOT}" usermod -aG sudo "${USERNAME}"
        log_message "User created: ${USERNAME}"
        
        # Set root password
        echo "Setting root password..."
        echo "root:${ROOT_PASSWORD}" | chroot "${INSTALL_ROOT}" chpasswd
        log_message "Root password set"
        
        # Install selected package groups
        if [ ${#INSTALL_PACKAGES[@]} -gt 0 ]; then
            echo ""
            echo "Installing selected packages..."
            
            # Update package lists
            chroot "${INSTALL_ROOT}" apt-get update
            
            for group in "${INSTALL_PACKAGES[@]}"; do
                if [ -n "${PACKAGE_GROUPS[$group]:-}" ]; then
                    echo "Installing ${group} packages..."
                    # shellcheck disable=SC2086
                    chroot "${INSTALL_ROOT}" apt-get install -y ${PACKAGE_GROUPS[$group]} || true
                fi
            done
        fi
        
        # Execute post-installation commands
        if [ ${#POST_INSTALL_COMMANDS[@]} -gt 0 ]; then
            echo ""
            echo "Running post-installation commands..."
            log_message "Executing ${#POST_INSTALL_COMMANDS[@]} post-installation commands"
            
            for cmd in "${POST_INSTALL_COMMANDS[@]}"; do
                # Skip empty lines and comments
                if [[ -z "${cmd}" || "${cmd}" =~ ^[[:space:]]*# ]]; then
                    continue
                fi
                
                echo -e "${COLOR_CYAN}→${COLOR_RESET} ${cmd}"
                log_message "Post-install command: ${cmd}"
                
                if chroot "${INSTALL_ROOT}" /bin/bash -c "${cmd}"; then
                    echo -e "${COLOR_GREEN}  ✓ Success${COLOR_RESET}"
                else
                    echo -e "${COLOR_YELLOW}  ⚠ Command failed (exit code: $?) - continuing anyway${COLOR_RESET}"
                    log_message "WARNING: Post-install command failed: ${cmd}"
                fi
            done
            
            echo ""
            echo -e "${COLOR_GREEN}✓ Post-installation commands completed${COLOR_RESET}"
            log_message "Post-installation commands completed"
        fi
        
        # Install and configure bootloader
        echo ""
        echo "Installing bootloader..."
        
        # Detect firmware type
        local is_uefi=false
        if [ -d "/sys/firmware/efi" ]; then
            is_uefi=true
        fi
        
        # Install kernel first
        chroot "${INSTALL_ROOT}" apt-get install -y linux-image-amd64
        
        # Install GRUB based on firmware type
        if [ "${is_uefi}" = true ]; then
            # UEFI system - install grub-efi
            chroot "${INSTALL_ROOT}" apt-get install -y grub-efi-amd64 efibootmgr
            chroot "${INSTALL_ROOT}" grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=GvOS
        else
            # BIOS system - install grub-pc
            chroot "${INSTALL_ROOT}" apt-get install -y grub-pc
            chroot "${INSTALL_ROOT}" grub-install "${SELECTED_DISK}"
        fi
        
        # Generate GRUB configuration
        chroot "${INSTALL_ROOT}" update-grub
        log_message "Bootloader installed"
        
        # Generate fstab
        echo "Generating fstab..."
        {
            echo "# /etc/fstab: static file system information"
            echo "UUID=$(blkid -s UUID -o value "${SELECTED_PARTITION_ROOT}")  /  ext4  errors=remount-ro  0  1"
            if [ -n "${SELECTED_PARTITION_BOOT}" ]; then
                echo "UUID=$(blkid -s UUID -o value "${SELECTED_PARTITION_BOOT}")  /boot/efi  vfat  umask=0077  0  1"
            fi
        } > "${INSTALL_ROOT}/etc/fstab"
        
        # Enable networking
        echo "Configuring network..."
        
        # Install NetworkManager if selected in packages
        if printf '%s\n' "${INSTALL_PACKAGES[@]}" | grep -q "network"; then
            chroot "${INSTALL_ROOT}" apt-get install -y network-manager
        fi
        
        # Enable NetworkManager if it's installed
        if chroot "${INSTALL_ROOT}" systemctl list-unit-files | grep -q NetworkManager; then
            chroot "${INSTALL_ROOT}" systemctl enable NetworkManager 2>/dev/null || true
        fi
        
        echo ""
        echo -e "${COLOR_GREEN}✓ Installation completed successfully!${COLOR_RESET}"
        log_message "Installation completed successfully"
        
    else
        # Simulation mode
        echo "Installing packages..."
        echo -e "${COLOR_YELLOW}[SIMULATION MODE] Package installation in progress${COLOR_RESET}"
        echo ""
        
        local total=100
        for i in $(seq 1 ${total}); do
            show_progress "${i}" "${total}" "Installing system"
            sleep 0.05
        done
        
        echo ""
        echo ""
        
        # Simulate creating user
        echo "Creating user account..."
        log_message "Creating user: ${USERNAME}"
        sleep 1
        
        # Simulate setting hostname
        echo "Setting hostname..."
        log_message "Setting hostname: ${HOSTNAME}"
        sleep 1
        
        # Simulate configuring timezone
        echo "Configuring timezone..."
        log_message "Setting timezone: ${TIMEZONE}"
        sleep 1
        
        # Simulate installing bootloader
        echo "Installing bootloader..."
        log_message "Installing GRUB bootloader"
        sleep 2
        
        echo ""
        echo -e "${COLOR_GREEN}✓ Installation completed successfully!${COLOR_RESET}"
        log_message "Installation completed successfully (simulated)"
    fi
}

# Step 11: Completion
step_completion() {
    show_header
    echo -e "${COLOR_GREEN}${COLOR_BOLD}=== Installation Complete ===${COLOR_RESET}"
    echo ""
    
    message_box "Installation Complete" \
"${COLOR_GREEN}Congratulations!${COLOR_RESET}

GvOS has been successfully installed on your system.

${COLOR_BOLD}System Information:${COLOR_RESET}
  Hostname:    ${HOSTNAME}
  Username:    ${USERNAME}
  Timezone:    ${TIMEZONE}

${COLOR_BOLD}Next Steps:${COLOR_RESET}
  1. Remove the installation media
  2. Reboot your system
  3. Log in with your username and password

${COLOR_YELLOW}Note:${COLOR_RESET} The installation log has been saved to:
  ${LOG_FILE}

Thank you for choosing GvOS!

Press ENTER to exit the installer..."
    
    read -r
}

################################################################################
# MAIN INSTALLATION FLOW
# This function orchestrates the entire installation process
################################################################################

main() {
    # Load configuration file if it exists
    local config_file="/etc/gvos-installer.conf"
    if [ -f "${config_file}" ]; then
        # Source the configuration file safely
        # shellcheck source=/dev/null
        source "${config_file}" 2>/dev/null || true
        
        # Override defaults with config values if set
        [ -n "${INSTALLER_HOSTNAME:-}" ] && DEFAULT_HOSTNAME="${INSTALLER_HOSTNAME}"
        [ -n "${INSTALLER_USERNAME:-}" ] && DEFAULT_USERNAME="${INSTALLER_USERNAME}"
        [ -n "${INSTALLER_TIMEZONE:-}" ] && DEFAULT_TIMEZONE="${INSTALLER_TIMEZONE}"
        [ -n "${INSTALLER_DEBIAN_RELEASE:-}" ] && DEBIAN_RELEASE="${INSTALLER_DEBIAN_RELEASE}"
        [ -n "${INSTALLER_DEBIAN_MIRROR:-}" ] && DEBIAN_MIRROR="${INSTALLER_DEBIAN_MIRROR}"
        [ -n "${INSTALLER_DEBIAN_SECURITY_MIRROR:-}" ] && DEBIAN_SECURITY_MIRROR="${INSTALLER_DEBIAN_SECURITY_MIRROR}"
        [ -n "${INSTALLER_LOG_FILE:-}" ] && LOG_FILE="${INSTALLER_LOG_FILE}"
    fi
    
    # Initialize logging
    mkdir -p "$(dirname "${LOG_FILE}")"
    : > "${LOG_FILE}"
    
    log_message "GvOS Installer v${INSTALLER_VERSION} started"
    
    # Hide cursor for cleaner UI
    tput civis 2>/dev/null || true
    
    # Trap to cleanup on exit
    trap 'cleanup_and_exit' EXIT INT TERM
    
    # Installation steps
    step_welcome
    step_check_prerequisites
    step_network_configuration
    step_disk_partitioning
    step_base_installation
    step_user_configuration
    step_package_selection
    step_custom_commands
    
    # Show summary and confirm
    while ! step_installation_summary; do
        # Return to package selection if user wants to change settings
        step_package_selection
        step_custom_commands
    done
    
    # Perform the actual installation
    step_perform_installation
    
    # Show completion message
    step_completion
    
    log_message "GvOS Installer completed"
    
    # Cleanup and exit
    cleanup_and_exit 0
}

################################################################################
# ENTRY POINT
# Start the installer
################################################################################

# Check if script is being sourced or executed
if [ "${BASH_SOURCE[0]}" = "${0}" ]; then
    main "$@"
fi
